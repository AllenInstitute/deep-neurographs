"""
Created on Sat Dec 12 17:00:00 2023

@author: Anna Grim
@email: anna.grim@alleninstitute.org

...

"""

import os

import networkx as nx
import numpy as np

from deep_neurographs import graph_utils as gutils
from deep_neurographs import swc_utils, utils


def get_accepted_propoals_blocks(
    neurographs,
    preds,
    blocks,
    block_to_idxs,
    idx_to_edge,
    max_length,
    high_threshold=0.9,
    low_threshold=0.6,
    structure_aware=True,
):
    accepts = dict()
    for block_id in blocks:
        # Threshold prediction
        preds_upd = filter_preds(
            preds,
            idx_to_edge,
            low_threshold,
            valid_idxs=block_to_idxs[block_id],
        )

        # Get accepts
        if structure_aware:
            graph = neurographs[block_id].copy_graph()
            accepts[block_id], _ = get_structure_aware_accepts(
                neurographs[block_id],
                graph,
                preds_upd,
                max_length,
                high_threshold=high_threshold,
            )
        else:
            accepts[block_id] = preds.keys()
    return accepts


def get_accepted_proposals(
    neurograph,
    graph,
    preds,
    idx_to_edge,
    max_length,
    high_threshold=0.9,
    threshold=0.6,
    structure_aware=True,
):
    preds = filter_preds(preds, idx_to_edge, threshold)
    if structure_aware:
        return get_structure_aware_accepts(
            neurograph, graph, preds, max_length, high_threshold=high_threshold
        )
    else:
        return preds.keys()


def filter_preds(preds, idx_to_edge, threshold, valid_idxs=[]):
    """
    Filters predictions by iterating over "preds" and checking whether a
    given predicted probability is above "threshold".

    Parameters
    ----------
    preds : list
        Predicted probabilities generated by a machine learning model.
    idx_to_edge : dict
        Maps indices correspond to "preds" to an edge proposal id.
    threshold : float
        Number between 0 and 1 to threshold predicted probabilites.
    valid_idxs : list, optional
        List of indices that are valid to accept, applicable in the case where
        inference is being run on multiple blocks. The default is [].

    Returns
    -------
    dict
        Dictionary generated from "preds" whose probability is above
        threshold, where each item is an edge proposal id and corresponding
        predicted probability.

    """
    filtered_preds = dict()
    for i, pred_i in enumerate(preds):
        contained_bool = True if len(valid_idxs) == 0 else i in valid_idxs
        if pred_i > threshold and contained_bool:
            filtered_preds[idx_to_edge[i]] = pred_i
    return filtered_preds


def get_structure_aware_accepts(
    neurograph, graph, preds, max_length, high_threshold=0.9
):
    # Add best preds
    best_preds, best_confidences = get_best(
        neurograph, preds, high_threshold, max_length
    )
    accepts, graph = check_cycles(graph, best_preds, best_confidences)
    if len(best_preds) == len(preds.keys()):
        return accepts, graph

    # Add remaining preds
    best_preds = set(best_preds)
    good_preds = []
    good_confidence = []
    for proposal, confidence in preds.items():
        length = neurograph.proposal_length(proposal)
        if proposal not in best_preds and length < max_length:
            good_preds.append(proposal)
            good_confidence.append(confidence)

    more_accepts, graph = check_cycles(graph, good_preds, good_confidence)
    accepts.extend(more_accepts)
    return accepts, graph


def get_subgraphs(graph, edge):
    """
    Gets the connected component subgraphs corresponding to the nodes in edge.

    Parameters
    ----------
    graph : networkx.Graph
        Graph to be searched
    edge : frozenset
        Edge that connected components are extracted with.

    Returns
    -------
    networkx.Graph
        Connected component subgraphs corresponding to the nodes in edge.

    """
    i, j = tuple(edge)
    subgraph_1 = graph.subgraph(gutils.get_component(graph, i))
    subgraph_2 = graph.subgraph(gutils.get_component(graph, j))
    try:
        subgraph = nx.union(subgraph_1, subgraph_2)
        return subgraph
    except:
        return False


def check_cycles(graph, edges, probs):
    accepts = []
    for i in np.argsort(probs):
        subgraph = get_subgraphs(graph, edges[i])
        if subgraph:
            created_cycle, _ = gutils.creates_cycle(subgraph, tuple(edges[i]))
            if not created_cycle:
                graph.add_edges_from([tuple(edges[i])])
                accepts.append(edges[i])
    return accepts, graph


def get_best(neurograph, preds, threshold, max_length):
    """
    Gets the best proposals (i.e. simple proposals with high confidence).

    Parameters
    ----------
    neurograph : NeuroGraph
        Graph that inference is being performed on.
    preds : dict
        Dictionary that maps proposal ids to acceptance probability.
    threshold : float
        Threshold on acceptance probability for proposals.
    max_length : float
        Maximum length of a proposal that will be accepted. Note that long
        range proposals may be generated to provide additional context.

    Returns
    -------
    """
    edges = []
    probs = []
    for edge, prob in preds.items():
        length = neurograph.proposal_length(edge)
        accept = prob > threshold and length < max_length
        if neurograph.is_simple(edge) and accept:
            edges.append(edge)
            probs.append(prob)
    return edges, probs


def fuse_branches(neurograph, edges):
    for edge in edges:
        neurograph.merge_proposal(edge)
    return neurograph


# -- Save result --
def save_prediction(
    neurograph, accepted_proposals, output_dir, save_swcs=False
):
    # Initializations
    connections_path = os.path.join(output_dir, "connections.txt")
    corrections_dir = os.path.join(output_dir, "corrections")
    swc_zip_path = os.path.join(output_dir, "corrected-processed-swcs.zip")
    utils.mkdir(corrections_dir, delete=True)

    # Write Result
    n_swcs = gutils.count_components(neurograph)
    save_connections(neurograph, connections_path)
    if save_swcs:
        neurograph.to_zipped_swcs(swc_zip_path)
        save_corrections(neurograph, accepted_proposals, corrections_dir)
    else:
        print(f"Result contains {n_swcs} swcs!")


def save_corrections(neurograph, accepted_proposals, output_dir):
    for cnt, (i, j) in enumerate(accepted_proposals):
        # Info
        color = f"1.0 1.0 1.0"
        filename = f"merge-{cnt + 1}.swc"
        path = os.path.join(output_dir, filename)

        # Save
        xyz_i = neurograph.nodes[i]["xyz"]
        xyz_j = neurograph.nodes[j]["xyz"]
        swc_utils.save_edge(path, xyz_i, xyz_j, color=color, radius=3)


def save_connections(neurograph, path):
    """
    Saves predicted connections between connected components in a txt file.

    Parameters
    ----------
    neurograph : NeuroGraph
        Graph built from predicted swc files.
    accepted_proposals : list[frozenset]
        List of accepted edge proposals where each entry is a frozenset that
        consists of the nodes corresponding to a predicted connection.
    path : str
        Path that output is written to.

    Returns
    -------
    None

    """
    with open(path, "w") as f:
        for swc_id_i, swc_id_j in neurograph.merged_ids:
            f.write(f"{swc_id_i}, {swc_id_j}" + "\n")
