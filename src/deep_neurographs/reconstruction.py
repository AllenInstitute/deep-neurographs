"""
Created on Sat Dec 12 17:00:00 2023

@author: Anna Grim
@email: anna.grim@alleninstitute.org

...

"""

import networkx as nx
import os
from concurrent.futures import ProcessPoolExecutor, as_completed
from random import sample

import numpy as np

from deep_neurographs import graph_utils as gutils
from deep_neurographs import swc_utils, utils

BATCH_PERCENT = 0.25


def get_accepted_propoals_blocks(
    neurographs,
    graph,
    preds,
    blocks,
    block_to_idxs,
    idx_to_edge,
    high_threshold=0.9,
    low_threshold=0.6,
    structure_aware=True,
):
    accepts = dict()
    for block_id in blocks:
        # Get accepts
        preds = threshold_preds(
            preds,
            idx_to_edge,
            low_threshold,
            valid_idxs=block_to_idxs[block_id],
        )

        # Refine accepts wrt structure
        if structure_aware:
            accepts[block_id] = get_structure_aware_accepts(
                neurographs[block_id],
                graph,
                preds,
                high_threshold=high_threshold,
                low_threshold=low_threshold,
            )
        else:
            accepts[block_id] = preds.keys()
    return accepts


def get_accepted_proposals(
    neurograph,
    graph,
    preds,
    idx_to_edge,
    high_threshold=0.9,
    low_threshold=0.6,
    structure_aware=True,
):
    # Get positive edge predictions
    preds = threshold_preds(preds, idx_to_edge, low_threshold)
    if structure_aware:
        return get_structure_aware_accepts(
            neurograph,
            graph,
            preds,
            high_threshold=high_threshold,
            low_threshold=low_threshold,
        )
    else:
        return preds.keys()


def threshold_preds(preds, idx_to_edge, threshold, valid_idxs=[]):
    """
    Thresholds predictions by iterating over "preds" and checking whether a
    given predicted probability is above "threshold".

    Parameters
    ----------
    preds : list
        Predicted probabilities generated by a machine learning model.
    idx_to_edge : dict
        Maps indices correspond to "preds" to an edge proposal id.
    threshold : float
        Number between 0 and 1 to threshold predicted probabilites.
    valid_idxs : list, optional
        List of indices that are valid to accept, applicable in the case where
        inference is being run on multiple blocks. The default is [].

    Returns
    -------
    thresholded_preds
        Dictionary generated from "preds" whose probability is above
        threshold, where each item is an edge proposal id and corresponding
        predicted probability.

    """
    thresholded_preds = dict()
    for i, pred_i in enumerate(preds):
        contained_bool = True if len(valid_idxs) == 0 else i in valid_idxs
        if pred_i > threshold and contained_bool:
            thresholded_preds[idx_to_edge[i]] = pred_i
    return thresholded_preds


def get_structure_aware_accepts(
    neurograph, graph, preds, high_threshold=0.8, low_threshold=0.6
):
    # Add best preds
    best_preds, best_probs = get_best_preds(neurograph, preds, high_threshold)
    accepts = check_cycles_sequential(neurograph, best_preds, best_probs)
    if len(best_preds) == len(preds.keys()):
        return accepts

    # Add remaining preds
    best_preds = set(best_preds)
    good_preds = []
    good_probs = []
    for edge, prob in preds.items():
        if edge not in best_preds:
            good_preds.append(edge)
            good_probs.append(prob)

    more_accepts = check_cycles_sequential(neurograph, good_preds, good_probs)
    accepts.extend(more_accepts)
    return list(set(accepts))


def get_subgraphs(graph, edge):
    """
    Gets the connected component subgraphs corresponding to the nodes in edge.

    Parameters
    ----------
    graph : networkx.Graph
        Graph to be searched
    edge : frozenset
        Edge that connected components are extracted with.

    Returns
    -------
    networkx.Graph
        Connected component subgraphs corresponding to the nodes in edge.

    """
    i, j = tuple(edge)
    subgraph_1 = graph.subgraph(gutils.get_component(graph, i))
    subgraph_2 = graph.subgraph(gutils.get_component(graph, j))
    return nx.union(subgraph_1, subgraph_2)


def check_cycles_parallelized(graph, edge_list):
    """
    Checks whether each edge in "edge_list" creates a cycle in "graph" in a
    with a parallelized algorithm.

    Parameters
    ----------
    graph : networkx.Graph
        Graph to be searched.
    edge_list : list
        List of edges to be checked.

    Returns
    -------
    graph : networkx.Graph
        Graph with each edge in "edge_list" added
    fail : bool
        Indication of whether a cycle was created due to parallelization.

    """
    # Assign processes
    with ProcessPoolExecutor() as executor:
        processes = []
        for edge in edge_list:
            subgraph = get_subgraphs(graph, edge)
            executor.submit(gutils.creates_cycle, subgraph, edge)

    # Store result
    accepts = []
    for process in as_completed(processes):
        created_cycle, edge = process.result()
        if not created_cycle:
            accepts.append(edge)
            graph.add_edge_from([edge])

    fail = True if gutils.cycle_exists(graph) else False
    return accepts, fail


def check_cycles_sequential(graph, edges, probs):
    accepts = []
    for i in np.argsort(probs):
        subgraph = get_subgraphs(graph, edges[i])
        created_cycle, _ = gutils.creates_cycle(subgraph, tuple(edges[i]))
        if not created_cycle:
            accepts.append(edges[i])
    return accepts


def get_best_preds(neurograph, preds, threshold):
    edges = []
    probs = []
    for edge, prob in preds.items():
        if neurograph.is_simple(edge) and prob > threshold:
            edges.append(tuple(edge))
            probs.append(prob)
    return edges, probs


# -- Merge branches --
def fuse_branches(neurograph, edges):
    cnt = 0
    n_trues = 0
    n_falses = 0
    print("# nodes:", len(neurograph.nodes))
    for edge in edges:
        
        if edge in neurograph.proposals.keys():
            n_trues += 1
        else:
            n_falses += 1

        i, j = tuple(edge)
        #del neurograph.proposals[edge]
        if neurograph.is_leaf(i) and neurograph.is_leaf(j):
            cnt += 1
            neurograph = simple_fusion(neurograph, edge)
        else:
            neurograph = simple_fusion(neurograph, edge)
    print("% trues:", n_trues / len(edges))
    print("% false:", n_falses / len(edges))
    return neurograph


def simple_fusion(neurograph, edge):
    # Attributes
    i, j = tuple(edge)
    radii = np.array(
        [neurograph.nodes[i]["radius"], neurograph.nodes[j]["radius"]]
    )
    xyz = np.vstack([neurograph.nodes[i]["xyz"], neurograph.nodes[j]["xyz"]])

    # Add
    neurograph.add_edge(
        i, j, radius=radii, swc_id=neurograph.nodes[i]["swc_id"], xyz=xyz
    )
    return neurograph


def sample_neighbor(graph, i):
    return sample(list(graph.neighbors(i)), 1)[0]


def fusion(neurograph, edge):
    # Get nodes
    i, j = tuple(edge)
    nb_i = sample_neighbor(neurograph, i)
    nb_j = sample_neighbor(neurograph, j)

    # Get branch attributes
    branch_xyz_i = neurograph.get_branches(i, key="xyz")[0]
    branch_xyz_j = neurograph.get_branches(j, key="xyz")[0]
    branch_radii_i = neurograph.get_branches(i, key="radius")[0]
    branch_radii_j = neurograph.get_branches(j, key="radius")[0]

    # Fuse attributes
    radii = np.concatenate((np.flip(branch_radii_j), branch_radii_i))
    xyz = np.vstack((np.flip(branch_xyz_j, axis=0), branch_xyz_i))

    # Delete
    neurograph.remove_edge(i, nb_i)
    neurograph.remove_edge(j, nb_j)

    # Add
    neurograph.add_edge(
        nb_i, nb_j, radius=radii, swc_id=neurograph.nodes[i]["swc_id"], xyz=xyz
    )
    return neurograph


# -- Save result --
def save_prediction(neurograph, proposal_preds, output_dir):
    # Initializations
    corrections_dir = os.path.join(output_dir, "corrections")
    utils.mkdir(output_dir, delete=True)
    utils.mkdir(corrections_dir, delete=True)

    # Write Result
    neurograph.to_swc(output_dir)
    save_corrections(neurograph, proposal_preds, corrections_dir)


def save_corrections(neurograph, proposal_preds, output_dir):
    for cnt, (i, j) in enumerate(proposal_preds):
        # Info
        color = f"1.0 1.0 1.0"
        filename = f"merge-{cnt + 1}.swc"
        path = os.path.join(output_dir, filename)

        # Save
        xyz_i = neurograph.nodes[i]["xyz"]
        xyz_j = neurograph.nodes[j]["xyz"]
        swc_utils.save_edge(path, xyz_i, xyz_j, color=color, radius=3)
