"""
Created on Sat July 15 9:00:00 2023

@author: Anna Grim
@email: anna.grim@alleninstitute.org

Evaluates performance of edge classifiation model.

"""

METRICS_LIST = [
    "accuracy_dif",
    "accuracy",
    "precision",
    "recall",
    "f1",
    "# splits fixed",
    "# merges created",
]


def init_stats():
    """
    Initializes a dictionary that stores stats computes by routines in this
    module.

    Parameters
    ----------
    None

    Returns
    -------
    dict
        Dictionary that stores stats computes by routines in this module.

    """
    return dict([(metric, []) for metric in METRICS_LIST])


def run_evaluation(neurograph, accepts, proposals):
    """
    Runs an evaluation on the accuracy of the predictions generated by an edge
    classication model.

    Parameters
    ----------
    neurographs : list[NeuroGraph]
        Predicted neurographs.
    accepts : list
        Accepted proposals.
    proposals : list
        Proposals that were classified as either accept or reject.

    Returns
    -------
    dict
        Dictionary that stores the accuracy of the edge classification model
        on all edges (i.e. "Overall"), simple edges, and complex edges. The
        metrics contained in this dictionary are identical to "METRICS_LIST"].

    """
    # Initializations
    stats = {
        "Overall": init_stats(),
        "Simple": init_stats(),
        "Complex": init_stats(),
    }

    # Evaluation
    overall_stats = get_stats(neurograph, proposals, accepts)

    simple_stats = get_stats(
        neurograph, neurograph.simple_proposals(), accepts
    )

    complex_stats = get_stats(
        neurograph, neurograph.complex_proposals(), accepts
    )

    # Store results
    for metric in METRICS_LIST:
        stats["Overall"][metric].append(overall_stats[metric])
        stats["Simple"][metric].append(simple_stats[metric])
        stats["Complex"][metric].append(complex_stats[metric])

    return stats


def run_evaluation_blocks(neurographs, blocks, accepts):
    """
    Runs an evaluation on the accuracy of the predictions generated by an edge
    classication model for a given list of blocks.

    Parameters
    ----------
    neurographs : list[NeuroGraph]
        Predicted neurographs.
    blocks : list[str], optional
        List of block_ids that indicate which predictions to evaluate.
    accepts : list
        Accepted proposals.

    Returns
    -------
    dict[dict]
        Acuracy of the edge classification model on all edges, simple edges,
        and complex edges. The metrics contained in a sub-dictionary where the
        keys are identical to "METRICS_LIST"].

    """
    avg_wgts = {"Overall": [], "Simple": [], "Complex": []}
    stats = {
        "Overall": init_stats(),
        "Simple": init_stats(),
        "Complex": init_stats(),
    }
    for block_id in blocks:
        # Compute accuracy
        overall_stats_i = get_stats(
            neurographs[block_id],
            neurographs[block_id].proposals,
            accepts[block_id],
        )

        simple_stats_i = get_stats(
            neurographs[block_id],
            neurographs[block_id].simple_proposals(),
            accepts[block_id],
        )

        complex_stats_i = get_stats(
            neurographs[block_id],
            neurographs[block_id].complex_proposals(),
            accepts[block_id],
        )

        # Store results
        avg_wgts["Overall"].append(len(neurographs[block_id].proposals))
        avg_wgts["Simple"].append(
            len(neurographs[block_id].simple_proposals())
        )
        avg_wgts["Complex"].append(
            len(neurographs[block_id].complex_proposals())
        )
        for metric in METRICS_LIST:
            stats["Overall"][metric].append(overall_stats_i[metric])
            stats["Simple"][metric].append(simple_stats_i[metric])
            stats["Complex"][metric].append(complex_stats_i[metric])

    return stats, avg_wgts


def get_stats(neurograph, proposals, accepts):
    """
    Accuracy of the predictions generated by an edge classication model on a
    given block and "edge_type" (e.g. overall, simple, or complex).

    Parameters
    ----------
    neurograph : NeuroGraph
        Predicted neurograph
    proposals : set[frozenset]
        Set of edge proposals for a given "edge_type".
    accepts : numpy.ndarray
        Binary predictions of edges generated by classifcation model.

    Returns
    -------
    dict
        Results of evaluation where the keys are identical to "METRICS_LIST".

    """
    n_pos = len([e for e in proposals if e in neurograph.target_edges])
    a_baseline = n_pos / (len(proposals) if len(proposals) > 0 else 1)
    tp, fp, a, p, r, f1 = get_accuracy(neurograph, proposals, accepts)
    stats = {
        "# splits fixed": tp,
        "# merges created": fp,
        "accuracy_dif": a - a_baseline,
        "accuracy": a,
        "precision": p,
        "recall": r,
        "f1": f1,
    }
    return stats


def get_accuracy(neurograph, proposals, accepts):
    """
    Computes the following metrics for a given set of predicted edges:
    (1) true positives, (2) false positive, (3) precision, (4) recall, and
    (5) f1-score.

    Parameters
    ----------
    neurograph : NeuroGraph
        Predicted neurograph
    proposals : set[frozenset]
        Set of edge proposals for a given "edge_type".
    accepts : list
        Accepted proposals.

    Returns
    -------
    float
        Number of true positives.
    float
        Number of false positives.
    float
        Precision.
    float
        Recall.
    float
        F1-score.

    """
    tp, tn, fp, fn = get_accuracy_counts(neurograph, proposals, accepts)
    a = (tp + tn) / len(proposals) if len(proposals) else 1
    p = 1 if tp + fp == 0 else tp / (tp + fp)
    r = 1 if tp + fn == 0 else tp / (tp + fn)
    f1 = (2 * r * p) / max(r + p, 1e-3)
    return tp, fp, a, p, r, f1


def get_accuracy_counts(neurograph, proposals, accepts):
    """
    Computes the following values: (1) true positives, (2) false positive, and
    (3) false negatives.

    Parameters
    ----------
    neurograph : NeuroGraph
        Predicted neurograph
    proposals : set[frozenset]
        Set of edge proposals for a given "edge_type".
    accepts : list
        Accepted proposals.

    Returns
    -------
    float
        Number of true positives.
    float
        Number of false positives.
    float
        Number of false negatives.

    """
    tp = 0
    tn = 0
    fp = 0
    fn = 0
    for edge in proposals:
        if edge in neurograph.target_edges:
            if edge in accepts:
                tp += 1
            else:
                fn += 1
        else:
            if edge in accepts:
                fp += 1
            else:
                tn += 1
    return tp, tn, fp, fn
